
-- Sets up lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not (vim.uv or vim.loop).fs_stat(lazypath) then
    local lazyrepo = "https://github.com/folke/lazy.nvim.git"
    local out = vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
    if vim.v.shell_error ~= 0 then
        vim.api.nvim_echo({
            { "Failed to clone lazy.nvim:\n", "ErrorMsg" },
            { out,                            "WarningMsg" },
            { "\nPress any key to exit..." },
        }, true, {})
        vim.fn.getchar()
        os.exit(1)
    end
end
vim.opt.rtp:prepend(lazypath)


-- Setup lazy.nvim
require("lazy").setup({
    spec = {
        { import = "plugins" },
    },
})



-- Setup lazy.nvim
require("lazy").setup({
    {
        "rebelot/kanagawa.nvim",
        config = function()
            vim.cmd.colorscheme("kanagawa-wave")
        end,
    },
    {
        "nvim-treesitter/nvim-treesitter",
        config = function ()
            require("nvim-treesitter.configs").setup({
                ensure_installed= {"c", "lua", "vim", "vimdoc", "query"}, -- best neovim experience
                auto_install= true,
                highlight={
                    enable=true,
                },
                incremental_selection = {
                    enable = true,
                    keymaps = {
                        init_selection = "<leader>ss",
                        node_incremental = "<leader>si",
                        scope_incremental = "<leader>sc",
                        node_decremental = "<leader>sd",
                    },
                },

                textobjects = {
                    select = {
                        enable = true,

                        -- Automatically jump forward to textobj, similar to targets.vim
                        lookahead = true,

                        keymaps = {
                            -- You can use the capture groups defined in textobjects.scm
                            ["af"] = "@function.outer",
                            ["if"] = "@function.inner",
                            ["ac"] = "@class.outer",
                            -- You can optionally set descriptions to the mappings (used in the desc parameter of
                            -- nvim_buf_set_keymap) which plugins like which-key display
                            ["ic"] = { query = "@class.inner", desc = "Select inner part of a class region" },
                            -- You can also use captures from other query groups like `locals.scm`
                            ["as"] = { query = "@local.scope", query_group = "locals", desc = "Select language scope" },
                        },
                        -- You can choose the select mode (default is charwise "v")
                        --
                        -- Can also be a function which gets passed a table with the keys
                        -- * query_string: eg "@function.inner"
                        -- * method: eg "v" or "o"
                        -- and should return the mode ("v", "V", or "<c-v>") or a table
                        -- mapping query_strings to modes.
                        selection_modes = {
                            ["@parameter.outer"] = "v", -- charwise
                            ["@function.outer"] = "V", -- linewise
                            ["@class.outer"] = "<c-v>", -- blockwise
                        },
                        -- If you set this to `true` (default is `false`) then any textobject is
                        -- extended to include preceding or succeeding whitespace. Succeeding
                        -- whitespace has priority in order to act similarly to eg the built-in
                        -- `ap`.
                        --
                        -- Can also be a function which gets passed a table with the keys
                        -- * query_string: eg "@function.inner"
                        -- * selection_mode: eg "v"
                        -- and should return true or false
                        include_surrounding_whitespace = true,
                    },
                },
            })
        end,
    },
    {
        "nvim-treesitter/nvim-treesitter-textobjects",
    },
    {
        "neovim/nvim-lspconfig",
        -- config = function()
        --     local lspconfig = require("lspconfig")

        --     lspconfig.clangd.setup({})
        -- end,
    },
    {
        "mason-org/mason.nvim",
        config = function()
            require("mason").setup()
        end,
        -- opts={}, -- same as::above
    },
    {
        "mason-org/mason-lspconfig.nvim",
        dependencies = {
            "mason-org/mason.nvim",
            "neovim/nvim-lspconfig", -- <- ensure lspconfig is available first (read docs)
        },
        config = function()
            require("mason-lspconfig").setup({
                -- ensure_installed = { "clangd"},
                automatic_enable = {
                    exclude = { "jdtls" }, -- <- mason won’t touch JDTLS (future issue)
                },
            })
        end,
    },



  -- path: nvim/lua/plugins/autocomplete.lua
  ---------------------------------------------------------------------------
  -- BLINK — fast, modern completion with your exact UX/visuals
  ---------------------------------------------------------------------------
  {
    "saghen/blink.cmp",
    event = "InsertEnter",
    version = "1.*",
    dependencies = {
      -- Snippet engine + community snippets (parity with your cmp stack)
      {
        "L3MON4D3/LuaSnip",
        build = (function()
          -- optional: build jsregexp for better regex perf (safe to skip)
          return "make install_jsregexp"
        end)(),
      },
      {
        "rafamadriz/friendly-snippets",
        config = function()
          require("luasnip.loaders.from_vscode").lazy_load()
        end,
      },

      -- Lua typing help when editing Lua
      {
        "folke/lazydev.nvim",
        ft = "lua",
        opts = {
          library = {
            { path = "${3rd}/luv/library", words = { "vim%.uv" } },
          },
        },
      },
    },

    ---@type blink.cmp.Config
    opts = {
      -----------------------------------------------------------------------
      -- KEYMAP: Tab/Shift-Tab cycles; Enter accepts; extras like you use
      -----------------------------------------------------------------------
      keymap = {
        preset        = "none",
        ["<Tab>"]     = { "select_next", "fallback" },
        ["<S-Tab>"]   = { "select_prev", "fallback" },
        ["<CR>"]      = { "accept", "fallback" },
        ["<C-e>"]     = { "hide" },
        ["<C-Space>"] = { "show", "show_documentation" },
        ["<Up>"]      = { "select_prev", "fallback" },
        ["<Down>"]    = { "select_next", "fallback" },
      },

      -----------------------------------------------------------------------
      -- APPEARANCE: VS Code-style icons; use Nerd Font Mono glyphs
      -----------------------------------------------------------------------
      appearance = {
        nerd_font_variant = "mono",
        kind_icons = {
          Text="", Method="󰆧", Function="󰊕", Constructor="", Field="",
          Variable="", Class="", Interface="", Module="", Property="",
          Unit="", Value="󰎠", Enum="", Keyword="", Snippet="", Color="",
          File="", Reference="", Folder="", EnumMember="", Constant="󰏿",
          Struct="", Event="", Operator="", TypeParameter="",
        },
      },

      -----------------------------------------------------------------------
      -- COMPLETION UI: no docs pane; short list; preselect like your cmp
      -----------------------------------------------------------------------
      completion = {
        documentation = { auto_show = false },
        list = {
          max_items = 50,
          selection = { preselect = true }, -- must be a TABLE (not string)
        },
      },

      -----------------------------------------------------------------------
      -- ENABLED GUARD: disable in comments + prompt buffers (no ctx arg)
      -----------------------------------------------------------------------
      enabled = function()
        -- Treesitter comment check
        local ok, ts_utils = pcall(require, "nvim-treesitter.ts_utils")
        if ok then
          local node = ts_utils.get_node_at_cursor()
          if node and node:type():match("comment") then
            return false
          end
        end
        -- Syntax group comment check
        local syn_id = vim.fn.synID(vim.fn.line("."), vim.fn.col("."), 1)
        local syn_name = vim.fn.synIDattr(syn_id, "name")
        if type(syn_name) == "string" and syn_name:lower():find("comment") then
          return false
        end
        -- No completion in prompt buftype
        local bt = vim.api.nvim_get_option_value("buftype", { buf = 0 })
        return bt ~= "prompt"
      end,

      -----------------------------------------------------------------------
      -- SOURCES: trimmed; tuned buffer; keep LazyDev priority boost
      -----------------------------------------------------------------------
      sources = {
        default = { "lazydev", "lsp", "path", "snippets", "buffer" },
        providers = {
          lazydev = {
            name = "LazyDev",
            module = "lazydev.integrations.blink",
            score_offset = 100,
          },
          buffer = {
            min_keyword_length = 3,
            max_items = 50,
          },
          path = {
            trailing_slash = true,
          },
          -- snippets provider will pick up LuaSnip + friendly-snippets
        },
      },

      -----------------------------------------------------------------------
      -- FUZZY: prefer native Rust matcher for lowest latency
      -----------------------------------------------------------------------
      fuzzy = { implementation = "prefer_rust_with_warning" },
    },

    config = function(_, opts)
      require("blink.cmp").setup(opts)

      -- Subtle UI tweaks to mirror your cmp look
      local set = vim.api.nvim_set_hl
      set(0, "BlinkCompletionBorder", { fg = "#404040" })
      set(0, "BlinkCompletionSel",    { bg = "#1c1e2b" })
      -- inherit other colors from your theme; add more Blink groups if desired
    end,

    -- allow extending the default source list elsewhere
    opts_extend = { "sources.default" },
  },

  ---------------------------------------------------------------------------
  -- AUTOPAIRS — basic setup (no cmp-specific integration needed for Blink)
  ---------------------------------------------------------------------------
  {
    "windwp/nvim-autopairs",
    event = "InsertEnter",
    opts = {
      check_ts = true,
      fast_wrap = { map = "<M-e>", offset = -1 },
      disable_filetype = { "TelescopePrompt", "spectre_panel" },
    },
    config = function(_, opts)
      require("nvim-autopairs").setup(opts)
      -- NOTE: do NOT require("nvim-autopairs.completion.cmp") here,
      -- since you're using Blink (not cmp). Base autopairs works fine.
    end,
  },



})
